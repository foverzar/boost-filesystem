[/
 / Copyright Andrey Semashev 2024.
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at
 / https://www.boost.org/LICENSE_1_0.txt)
 /]

[section:reference Reference]

[section:intro Introduction]

This reference documentation describes components that C++ programs may use to perform operations involving file systems, including paths, regular files,
and directories.

[section:conformance Conformance \[fs.conformance\]]

[section:iso_iec_9945 ISO/IEC 9945 conformance \[fs.conform.9945\]]

Some behavior in this reference documentation is specified by reference to ISO/IEC 9945. How such behavior is actually implemented is unspecified.

[note This constitutes an "as if" rule for implementation of operating system dependent behavior. In practice implementations will usually call native
operating system API's.]

Implementations are encouraged to provide such behavior as it is defined by ISO/IEC 9945. Implementations shall document any behavior that differs from
the behavior defined by ISO/IEC 9945. Implementations that do not support exact ISO/IEC 9945 behavior are encouraged to provide behavior as close
to ISO/IEC 9945 behavior as is reasonable given the limitations of actual operating systems and file systems. If an implementation cannot provide any
reasonable behavior, the implementation shall report an error in an implementation-defined manner.

[note Such errors might be reported by an `#error` directive, a `static_assert`, a [class_filesystem_filesystem_error] exception, a special return value,
or some other manner.]

Implementations are not required to provide behavior that is not supported by a particular file system.

[tip The [@https://en.wikipedia.org/wiki/FAT_filesystem FAT file system] used by some memory cards, camera memory, and floppy discs does not support
hard links, symlinks, and many other features of more capable file systems. Implementations are only required to support the FAT features supported
by the host operating system.]

The behavior of functions described in this reference may differ from their specification in the presence of
[link filesystem.reference.intro.defs.file-system-race file system races]. No diagnostic is required.

If the possibility of a file system race would make it unreliable for a program to test for a precondition before calling a function described in this
reference documentation, [*Requires] is not specified for the condition. Instead, the condition is specified as a [*Throws] condition.

[note As a design practice, preconditions are not specified when it is unreasonable for a program to detect them prior to calling the function.]

[endsect]

[section:os Operating system dependent conformance \[fs.conform.os\]]

Some behavior is specified in this reference documentation as being operating system dependent (\[fs.def.osdep\]). The operation system an implementation
is dependent upon is implementation defined.

It is permissible for an implementation to be dependent upon an operating system emulator rather than the actual operating system.

[tip ['Example:] An implementation uses [@https://cygwin.com/ Cygwin], a Linux® API emulator for some Windows® operating system versions. The implementation
would define Cygwin as its operating system. Users could refer to the Cygwin documentation to find details of the operating system dependent behavior.

It is user and conformance test detectable that such an implementation is running on Cygwin. Users would be misled and conformance tests would fail
if the implementation defined Linux or Windows rather than Cygwin as the operating system, since real behavior is a blend of the two.]

[endsect]

[endsect]

[section:defs Definitions \[fs.definitions\]]

The following definitions shall apply throughout this reference documentation:

[variablelist
[
    [operating system dependent behavior \[fs.def.osdep\]]
    [Behavior  that is dependent upon the behavior and characteristics of an operating system. See \[fs.conform.os\].]
]
[
    [[#filesystem.reference.intro.defs.file]file \[fs.def.file\]]
    [An object that can be written to, or read from, or both. A file has certain attributes, including type. File types include regular files
    and directories. Other types of files, such as symbolic links, may be supported by the implementation.]
]
[
    [[#filesystem.reference.intro.defs.filesystem]file system \[fs.def.filesystem\]]
    [A collection of files and their attributes.]
]
[
    [[#filesystem.reference.intro.defs.filename]filename \[fs.def.filename\]]
    [The name of a file. Filenames "." and ".." have special meaning. The following characteristics of filenames are operating system dependent:

    * The permitted characters. See [link filesystem.reference.path.os-examples \[fs.os.examples\]].
    * Specific filenames that are not permitted.
    * Additional filenames that have special meaning.
    * Case awareness and sensitivity during path resolution.
    * Special rules that may apply to file types other than regular files, such as directories.
    ]
]
[
    [[#filesystem.reference.intro.defs.path]path \[fs.def.path\]]
    [A sequence of elements that identify the location of a file within a filesystem. The elements are the ['root-name[sub opt]],
    ['root-directory[sub opt]], and an optional sequence of filenames.
    [note A [link filesystem.reference.intro.defs.pathname pathname] is the concrete representation of a path.]
    ]
]
[
    [[#filesystem.reference.intro.defs.absolute-path]absolute path \[fs.def.absolute-path\]]
    [A path that unambiguously identifies the location of a file without reference to an additional starting location. The elements of a path
    that determine if it is absolute are operating system dependent.]
]
[
    [[#filesystem.reference.intro.defs.relative-path]relative path \[fs.def.relative-path\]]
    [A path that is not absolute, and so only unambiguously identifies the location of a file when resolved relative to an implied starting location.
    The elements of a path that determine if it is relative are operating system dependent.
    [note Paths "." and ".." are relative paths.]
    ]
]
[
    [[#filesystem.reference.intro.defs.canonical-path]canonical path \[fs.def.canonical-path\]]
    [An absolute path that has no elements that are symbolic links, and no "." or ".." elements.]
]
[
    [[#filesystem.reference.intro.defs.pathname]pathname \[fs.def.pathname\]]
    [A character string that represents the name of a path. Pathnames are formatted according to the generic pathname grammar or an operating system
    dependent native pathname format.]
]
[
    [[#filesystem.reference.intro.defs.native-format]native pathname format \[fs.def.native\]]
    [The operating system dependent pathname format accepted by the host operating system.]
]
[
    [[#filesystem.reference.intro.defs.normal-form]normal form path \[fs.def.normal\]]
    [A path with no redundant directory separators, current directory (['dot]) or parent directory (['dot-dot]) elements. The normal form for
    an empty path is an empty path. \[[*v3:] The normal form for a path ending in a ['directory-separator] that is not the root directory
    is the same path with a current directory (['dot]) element appended.\]]
]
[
    [[#filesystem.reference.intro.defs.link]link \[fs.def.link\]]
    [A directory entry object that associates a filename with a file. On some file systems, several directory entries can associate names with
    the same file.]
]
[
    [[#filesystem.reference.intro.defs.hard-link]hard link \[fs.def.hardlink\]]
    [A link to an existing file. Some file systems support multiple hard links to a file. If the last hard link to a file is removed, the file
    itself is removed.
    [note A hard link can be thought of as a shared-ownership smart pointer to a file.]
    ]
]
[
    [[#filesystem.reference.intro.defs.symbolic-link]symbolic link \[fs.def.symlink\]]
    [A type of file with the property that when the file is encountered during pathname resolution, a string stored by the file is used to modify
    the pathname resolution.
    [note A symbolic link can be thought of as a raw pointer to a file. If the file pointed to does not exist, the symbolic link is said to be a
    "dangling" symbolic link.]
    ]
]
[
    [[#filesystem.reference.intro.defs.file-system-race]file system race \[fs.def.race\]]
    [The condition that occurs when multiple threads, processes, or computers interleave access and modification of the same object within
    a file system.]
]
]

[endsect]

[endsect]

[section:path Path]

[section:generic-pathname-format Generic pathname format \[path.generic\]]

[pre
pathname:
    root-name[sub opt] root-directory[sub opt] relative-path[sub opt]

root-name:
    ['An operating system dependent name that identifies the starting location for absolute paths.]

root-directory:
    directory-separator

relative-path:
    filename
    relative-path directory-separator
    relative-path directory-separator filename

filename:
    name
    "."
    ".."

preferred-separator:
    ['An operating system dependent directory separator character. May be a synonym for "/".]

directory-separator:
    "/"
    "/" directory-separator
    preferred-separator
    preferred-separator directory-separator
]

[note Many operating systems define a name beginning with two ['directory-separator] characters as a ['root-name] that identifies network
or other resource locations. Some operating systems define a single letter followed by a colon as a drive specifier - a ['root-name]
identifying a specific device such as a disc drive.]

Multiple successive ['directory-separator] characters are considered to be the same as one ['directory-separator] character.

The ['filename] "." is considered to be a reference to the current directory. The ['filename] ".." is considered to be a reference to the
parent directory. Specific ['filenames] may have special meanings for a particular operating system.

[endsect]

[section:os-examples Operating system dependent examples (Informative) \[fs.os.examples\]]

Certain features are specified in this reference documentation as being operating system dependent. The following table shows the application
of those specifications for operating systems that use the ISO/IEC 9945 or Windows application program interfaces (APIs).
[link filesystem.reference.path.os-examples.footnote1 [super \[1\]]]

[table
[[Feature] [Section] [ISO/IEC 9945 POSIX API] [Windows API] [Notes]]
[[
`path::value_type`
]
[
[class path]
]
[
`char`
]
[
`wchar_t`
]
[
]]
[[
`path::preferred_separator`
]
[
[class path]
]
[
`'/'`
]
[
`L'\\\\'` (single backslash)
]
[
]]
[[
`path("/").is_absolute()`
]
[
[member path::is_absolute]
]
[
`true`
]
[
`false`
]
[
]]
[[
`path("c:/").is_absolute()`
]
[
[member path::is_absolute]
]
[
`false`
]
[
`true`
]
[
]]
[[
`path` argument disambiguation between generic format and native format
]
[
[link filesystem.reference.path.conversions.format \[path.arg.fmt.cvt\]]
]
[
Not required
]
[
Not required
]
[
There is no need to distinguish between the generic format and native format for these operating systems.
]]
[[
`path` argument format conversion
]
[
[link filesystem.reference.path.conversions.format \[path.arg.fmt.cvt\]]
]
[
No conversion performed
]
[
No conversion performed
]
[
The generic format is already acceptable to the native API of these operating systems.
]]
[[
`path("/cats/jane").c_str()`
]
[
[link filesystem.reference.path.conversions.format \[path.arg.fmt.cvt\]]
]
[
`"/cats/jane"`
]
[
`L"/cats/jane"`
]
[
These operating systems accept the same native separator between directory names and a final file name, so no format conversion is performed.
Other operating systems might require conversion.
]]
[[
`path("/cats/jane/").c_str()`
]
[
[link filesystem.reference.path.conversions.format \[path.arg.fmt.cvt\]]
]
[
`"/cats/jane/"`
]
[
`L"/cats/jane/"`
]
[
These operating systems accept the same native separator between directory names and a final file name, so no format conversion is performed.
Other operating systems might require conversion.
]]
[[
Format conversion by `path` native format observers
]
[
[member path::native]
]
[
No conversion performed
]
[
No conversion performed
]
[
For efficiency, `path` objects are required to store pathnames in the native format regardless of operating system.
]]
[[
Format conversion by `path` generic format observers
]
[
[member path::generic_path]
]
[
No conversion performed
]
[
Backslashes converted to slashes
]
[
]]
[[
`p.make_preferred()`
]
[
[member path::make_preferred]
]
[
No change
]
[
Slashes converted to backslashes
]
[
]]
[[
Characters prohibited in filenames
]
[
[link filesystem.reference.intro.defs.filename \[fs.def.filename\]]
]
[
0x00, `'/'`
]
[
0x00-0x1F, `'"'`, `'*'`,` '*'`, `'<'`, `'>'`, `'?'`, `'\\\\'` (single backslash), `'/'`, `'|'`
]
[
Many operating systems prohibit the ASCII control characters (0x00-0x1F) in filenames.
]]
[[
Initial imbued `path` locale
]
[
[member path::imbue], [member path::codecvt]
]
[
`std::locale("")`[link filesystem.reference.path.os-examples.footnote2 [super \[2\]]]
]
[
Implementation supplied locale using `MultiByteToWideChar` and `WideCharToMultiByte` with a codepage of `CP_ACP`
if `AreFileApisANSI` is true, otherwise codepage `CP_OEMCP`.[link filesystem.reference.path.os-examples.footnote3 [super \[3\]]]
]
[
Apple OS X®: Implementation supplied locale providing UTF-8 `codecvt` facet.[link filesystem.reference.path.os-examples.footnote4 [super \[4\]]]
]]
]

[#filesystem.reference.path.os-examples.footnote1][super \[1\]] OS X® and Windows® are examples of commercially available operating systems. This information
is given for the convenience of users of this document and does not constitute an endorsement by ISO or IEC of these products.

[#filesystem.reference.path.os-examples.footnote2][super \[2\]] Rationale: ISO C specifies `std::locale("")` as "the locale-specific native environment",
while ISO/IEC 9945 says it "Specifies an implementation-defined native environment."

[#filesystem.reference.path.os-examples.footnote3][super \[3\]] Rationale: This is the current behavior of C and C++ standard library functions that perform
file operations using narrow character strings to identify paths. Changing this behavior would be surprising and at variance with existing code,
particularly where user input is involved.

[#filesystem.reference.path.os-examples.footnote4][super \[4\]] Rationale: Vendor's documentation states "All BSD system functions expect their string parameters
to be in UTF-8 encoding and nothing else."

[endsect]

[section:iterators Iterators]

[endsect]

[xinclude path_reference.xml]

[endsect]

[xinclude operations_reference.xml]
[xinclude directory_reference.xml]
[xinclude file_status_reference.xml]
[xinclude exception_reference.xml]
[xinclude io_reference.xml]

[endsect]
